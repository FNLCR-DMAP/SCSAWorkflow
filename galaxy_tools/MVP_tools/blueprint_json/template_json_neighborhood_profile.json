{
  "rid": "ri.vector.main.template.c680e05f-3f35-48d6-9f62-0a376d2cf88c",
  "title": "Neighborhood Profile [SPAC][DMAP]",
  "description": "Calculate the neighborhood profile in terms of count of neighbor cells for every cell.\\\nPlease refer to [DUET Documentation](https://nidap.nih.gov/workspace/notepad/view/ri.notepad.main.notepad.2a54d92e-9b97-40cf-913b-84cc7a9340b0), [GitHub Documentation](https://fnlcr-dmap.github.io/SCSAWorkflow/modules/spac.spatial_analysis.neighborhood_profile.html) for further information.",
  "createdBy": "391048e4-979e-4237-a0f4-9f34b125a427",
  "createdAt": "2025-05-30T18:35:53.943057454Z",
  "commitMessage": "spac v0.9.0 new github link",
  "status": "RELEASED",
  "inputDatasets": [
    {
      "key": "Upstream_Analysis",
      "displayName": "Upstream Analysis",
      "description": "Link to prior processed dataset in the analysis.",
      "paramGroup": null,
      "anchorDataset": null,
      "dataType": "PYTHON_TRANSFORM_INPUT",
      "tags": []
    }
  ],
  "parameters": [
    {
      "key": "Annotation_of_interest",
      "displayName": "Annotation of interest",
      "description": "Annotation of interest to define cell labels.",
      "paramType": "STRING",
      "paramGroup": null,
      "paramValues": null,
      "defaultValue": "",
      "condition": null,
      "content": null,
      "objectPropertyReference": null
    },
    {
      "key": "Bins",
      "displayName": "Bins",
      "description": "Radii in micro meter that form the bands around the center phenotype to count the neighbor cells",
      "paramType": "LIST",
      "paramGroup": null,
      "paramValues": null,
      "defaultValue": null,
      "condition": null,
      "content": null,
      "objectPropertyReference": null
    },
    {
      "key": "Stratify_By",
      "displayName": "Stratify By",
      "description": "The annotation to stratify the dataset when generating the profiles (e.g., slide name). If a value other than \"None\" is passed, the dataset will be stratified by the unique labels in the annotation column. Use \"None\" without quotes to disable (e.g., all cells are from one region or slide)",
      "paramType": "STRING",
      "paramGroup": null,
      "paramValues": null,
      "defaultValue": "",
      "condition": null,
      "content": null,
      "objectPropertyReference": null
    },
    {
      "key": "Anchor_Neighbor_List",
      "displayName": "Anchor Neighbor List",
      "description": "A list of anchor;neighbor cell labels to generate the results. The two types should be separated with a ';'. For example, if  if the anchor is \"T cells\" and the neighbor is \"B cells\", enter the value: \"T cells; B cells\" without the quotes.",
      "paramType": "LIST",
      "paramGroup": null,
      "paramValues": null,
      "defaultValue": null,
      "condition": null,
      "content": null,
      "objectPropertyReference": null
    }
  ],
  "columns": [],
  "orderedMustacheKeys": [
    "neighborhood_profile",
    "Annotation_of_interest",
    "Bins",
    "Stratify_By",
    "Anchor_Neighbor_List"
  ],
  "contents": {
    "type": "code",
    "code": {
      "codeLanguage": "PYTHON",
      "codeTemplate": "# DEV Spatial UMAP [SPAC][DMAP] (a3dd21d6-11f1-4879-b438-3c47b2d93f35): v12\ndef unnamed_5({{{neighborhood_profile}}}):\n    \n    import pickle\n    from spac.transformations import normalize_features\n    import pandas as pd\n    from code_workbook_utils.utils import text_to_value\n    from spac.spatial_analysis import neighborhood_profile\n    import pandas as pd\n    import numpy as np\n    from code_workbook_utils.utils import text_to_value\n\n\n    cell_types_annotation = \"{{{Annotation_of_interest}}}\"\n    bins = {{{Bins}}}\n    slide_names = \"{{{Stratify_By}}}\"\n    normalization = None\n    output_table = \"neighborhood_profile\"\n\n    anchor_neighbor_list = {{{Anchor_Neighbor_List}}}\n    anchor_neighbor_list = [\n        tuple(map(str.strip, item.split(\";\"))) for item in anchor_neighbor_list]\n\n    NIDAP_dataset = {{{neighborhood_profile}}}.filesystem()\n    with NIDAP_dataset.open(\"transform_output.pickle\", \"rb\") as input_file:\n        adata = pickle.load(input_file)\n    #Call the spatial umap calculation\n\n    bins = [float(radius) for radius in bins]\n\n    slide_names = text_to_value(slide_names)\n\n    neighborhood_profile(\n        adata,\n        phenotypes=cell_types_annotation,\n        distances=bins,\n        regions=slide_names,\n        spatial_key=\"spatial\",\n        normalize=normalization,\n        associated_table_name=output_table\n    )\n\n    print(adata)\n    print(adata.obsm[output_table].shape)\n    print(adata.uns[output_table])\n\n\n    dataframes, filenames = neighborhood_profiles_for_pairs(\n        adata,\n        cell_types_annotation,\n        slide_names,\n        bins,\n        anchor_neighbor_list,\n        output_table\n    )\n\n    # Transfer data through pickle method and filesystem on NIDAP\n    output = Transforms.get_output()\n    output_fs = output.filesystem()\n\n    for (anchor_label, neighbor_label), filename in zip(dataframes.keys(), filenames):\n        df = dataframes[(anchor_label, neighbor_label)]  # Retrieve DataFrame\n\n        # Open file and save CSV\n        with output_fs.open(filename, \"w\") as f:\n            df.to_csv(f, index=False)\n\n        print(f\"Saved: {filename}\")\n\n    # with output_fs.open('transform_output.pickle', 'wb') as f:\n    #     pickle.dump(adata, f)\n\n    # return(None)\n\n#################################################\n## Global imports and functions included below ##\n#################################################\n\nimport pandas as pd\nimport numpy as np\n\ndef neighborhood_profiles_for_pairs(\n    adata,\n    cell_types_annotation,\n    slide_names,\n    bins,\n    anchor_neighbor_list,\n    output_table\n):\n    \"\"\"\n    Compute neighborhood profiles for all anchor-neighbor pairs and return a tuple \n    containing a dictionary of DataFrames and a list of filenames for saving.\n\n    Parameters\n    ----------\n    adata : AnnData\n        The AnnData object containing spatial and phenotypic data.\n\n    cell_types_annotation : str\n        The column name in adata.obs containing the cell phenotype labels.\n\n    slide_names : str\n        The column name in adata.obs containing the slide names.\n\n    bins : list\n        List of increasing distance bins.\n\n    anchor_neighbor_list : list of tuples\n        List of (anchor_label, neighbor_label) pairs.\n\n    output_table : str\n        The key in adata.obsm containing neighborhood profile data.\n\n    Returns\n    -------\n    tuple\n        - A dictionary of DataFrames for each (anchor, neighbor) pair.\n        - A list of filenames where each DataFrame should be saved.\n    \"\"\"\n\n    dataframes = {}\n    filenames = []\n\n    # Get the array of neighbor labels\n    neighbor_labels = adata.uns[output_table][\"labels\"]\n\n    for anchor_label, neighbor_label in anchor_neighbor_list:\n        # Create bin labels with the neighbor type\n        bins_with_ranges = [f\"{neighbor_label}_{bins[i]}-{bins[i+1]}\" for i in range(len(bins) - 1)]\n\n        # Find the index of the requested neighbor label\n        neighbor_index = np.where(neighbor_labels == neighbor_label)[0]\n\n        if len(neighbor_index) == 0:\n            raise ValueError(f\"Neighbor label '{neighbor_label}' not found in {output_table} labels.\")\n\n        neighbor_index = neighbor_index[0]  # Extract the first index\n\n        # Extract the neighborhood profile for the specific neighbor\n        profile_data = adata.obsm[output_table][:, neighbor_index, :]  # Shape: (n_cells, n_bins)\n\n        # Construct DataFrame\n        df = pd.DataFrame(profile_data, columns=bins_with_ranges)\n\n        # Add cell phenotype labels and slide names\n        df.insert(0, cell_types_annotation, adata.obs[cell_types_annotation].values)\n        if slide_names is not None:\n            df.insert(0, slide_names, adata.obs[slide_names].values)\n\n        # Filter for the anchor cell type\n        filtered_df = df[df[cell_types_annotation] == anchor_label]\n\n        # Generate a filename for saving\n        filename = f\"anchor_{anchor_label}_neighbor_{neighbor_label}.csv\"\n\n        # Store the DataFrame and filename\n        dataframes[(anchor_label, neighbor_label)] = filtered_df\n        filenames.append(filename)\n\n    return dataframes, filenames\n\n\n\n\n\n#################################################\n## Global imports and functions included below ##\n#################################################\n\n\n",
      "shouldPersist": true
    }
  },
  "version": 9,
  "externalId": null,
  "canEditTemplate": true,
  "path": "/NIDAP/NCI-Wide Analysis & Visualization Resources/SPAC/SPAC Templates/Neighborhood Profile [SPAC][DMAP]",
  "tags": [],
  "favorite": false,
  "namedCollections": [],
  "isDefault": true,
  "condaDependencies": [
    "python=3.6"
  ],
  "outputDatasetName": "neighborhood_profile",
  "outputs": {
    "dataframe": {"type": "directory", "name": "dataframe_dir"}
  }
}